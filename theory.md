## REST API

### REST

* `API` - application programming interface - набор функций, для взаимодействия с чем-либо

* Набор правил и рекомендаций

* Подразумевает полноценное использование HTTP-методов
    * POST - для добавления (данные передаем в теле запроса в формате JSON)
    * GET - для получения
    * DELETE - для удаления
    * PUT - для обновления (данные передаем в теле запроса в формате JSON)
* При добавлении чего-либо в ответ возвращаем то же самое, что добавили
* Подразумевает полноценное использование статусов
* Правильное именование endpoints

```
Именуем их так, будто они - папки с файлами и подпапками (ресурсо-ориентированный подход)

/users - все пользователи

/users/1 - пользователь с id = 1

/users/1/articles - все статьи пользователя с id = 1
```

* Хороший стиль - начинать свои endpoints c префикса `api`
* Хороший стиль - использовать параметры запроса `?key1=value1&key2=value2..` для фильтрации и поиска

### Задачи

- Добавить событие
- Получить список всех пользователей
- Получить список всех событий
- Зарегистрировать пользователя на событие
- Посмотреть всех участников определенного события
- Посмотреть все события определенного пользователя

### Важные заметки

#### Dto - Data Transfer Object

* Зачастую возникают ситуации, когда наш API отличается от моделей (какие-то поля отсутствуют, какие-то присутствует,
  какие-то выглядят по другому и т.д.)
* Для решения этой проблемы мы на уровне контроллеров и сервисов не используем модели, а используем Dto
* Dto - это подход, при котором мы создаем дополнительные классы, отвечающие требованиям API

#### Аннотации в контроллерах

* `@ResponseBody` - показывает, что нужно вернуть данные в теле ответа в формате JSON
* `@RequestBody` - показывает, что нужно вытащить данные из тела запроса в формате JSON
* `@RequestMapping` - просто говорит, что данный метод или контроллер должен срабатывать на нужный URL
* `@RestController` - эта аннотация позволяет избавиться от написания `@ResponseBody` для каждого
* `@PathVariable` - эта аннотация позволяет вытащить часть URL, который заключен в фигурные скобки. "Переменная пути"
* `@RequestParam` - эта аннотация позволяет вытащить параметр запроса из URL (например, `?year=10`)

#### Ссылочные в моделях

* Не используем примитивные типы в моделях
* Потому что ссылочные типы позволяют хранить значение null
* В базе какой-то столбец может быть null и в программе тоже должно быть null
* Например, кто-то не захотел указывать свой возраст, тогда его age = null
* Не логично, чтобы возраст был 0

### HTTP-запрос

* Чтобы сервер понимал, в каком формате мы передаем ему данные, мы отправляем их вместе с заголовком:
    * Content-Type: application/json
* Чтобы клиент понимал, как отработал запрос, сервер отправляет ему в ответе статус (целое число, идентифицирующее
  ситуацию)
    * 200 - все хорошо
    * 201 - создано
    * 404 - если не найден соответствующий URL (endpoint)
    * 500 - на сервере произошла ошибка
    * 403 - запрещено (у пользователя нет прав)
    * 401 - пользователь не авторизован
    * 405 - не поддерживается метод
    * и так далее

### Работа в IntelliJ IDEA

* Если хотите посмотреть использование или объявление чего-либо, нажимайте Ctrl + B (при этом курсор должен стоять на
  том, что вы хотите) либо Ctrl + ЛКМ
* Если хотите посмотреть реализацию метода через интерфейс - Ctrl + Alt + B
* Между вкладками я переключаюсь с помощью зажатия Ctrl и нажатия Tab
* Если нужно быстро переключиться между двумя вкладками просто нажимаем быстро

### Интеграционный тест

* Тяжеловесный тест, который полностью поднимает все приложение со всеми конфигурациями
* `@SpringBootTest` - аннотация, которая говорит, что для этого теста нужно поднять конфигурацию Spring Boot
* `@AutoConfigureMockMvc` - аннотация, которая включает конфигурацию `MockMvc`
* `MockMvc` - класс, который позволяет отправлять запросы на ваш сервер и получать ответы

### Еще дополнительные замечания

* `@EqualsAndHashCode(exclude = "events")` - убираем поле `events` при генерации `equals()` и `hashCode()`
* `Optional<T>` - встроенный в Java класс, который явно позволяет показать, что может вернутся `null`

### Глобальный порядок операций

1. Описать задачу (см. README.md)
2. Описать в API-слое запрос вместе с документацией
3. Реализовать метод в Controllers, Services, Repositories и т.д.
4. Предусмотреть ошибочные ситуации
5. Проверить через requests.http
6. Написать тест и проверить тест для разных случаев
7. Проверить через Swagger

## Повторение

### Архитектура проекта

* Классическая "Three-Tier Architecture" или "Three-Layer Architecture"

* `Models/Entities` - модели предметной области, каждый объект хранит какие-либо данные
* `Services` - бизнес-логика, основные алгоритмы вашей системы
* `Dto` - Data Transfer Object, слой, представляет собой данные, которые вы отправляете (клиенту) или получаете (от
  клиента).
* Этот слой очень важен и должен присутствовать всегда на всех методах сервисов/контроллеров
* Потому что данные у вас внутри системы могут отличаться от того, что вы получаете или отдаете
* Также в этом слое мы ставим аннотации для документации и валидации
* `Repositories` - слой репозиториев (представлен интерфейсами и их реализациями) нужен для того, чтобы отделить логику
  хранения данных от бизнес-логики.
* Это нужно для того, чтобы обеспечить возможность изменения типа хранилища (База данных, файл, S3, обычный список)
* Слой `Controllers` нужен для того, чтобы взаимодействовать с клиентом независимо от протокола
* Мы делаем отдельно сервисы и контроллеры, чтобы не менять сервисы, если у нас измениться протокол общения с клиентом
    * HTTP (классические контроллеры)
    * WebSockets
    * GRPC
    * GraphQL

### Путь обработки запроса

```
POST localhost:8080/api/articles
Content-Type: application/json

{
  "text" : "Очень хорошо понимает Frontend!",
  "aboutUserId": 2,
  "publishDate": "2022-02-02"
}
```

* Он попадает в контроллер, который отвечает за `/api/articles` - это `ArticleController`
* Запрос обрабатывается методом:

```
public ArticleDto addArticle(NewArticleDto newArticle) {
  return articlesService.addArticle(newArticle);
}
```

* Данный метод контроллера является оберткой над аналогичным методом в сервисе, мы просто вызываем метод сервиса
* Этот метод реализован в классе `ArticlesServiceImpl`:

```java
class ArticlesServiceImpl {
    private final UsersRepository usersRepository;

    private final ArticlesRepository articlesRepository;

    @Override
    public ArticleDto addArticle(NewArticleDto newArticle) {
        // получаем пользователя по его id из репозитория или выбрасываем исключение, если его не нашли
        User user = usersRepository.findById(newArticle.getAboutUserId())
                .orElseThrow(() ->
                        new IncorrectUserIdException("Id <" + newArticle.getAboutUserId() + "> is not correct"));
        // создаем модель Article с нужными данными
        Article article = Article.builder()
                .text(newArticle.getText()) // берем текст из dto
                .about(user) // вставляем модель пользователя, которую получили на предыдущем шаге
                .publishDate(LocalDate.parse(newArticle.getPublishDate())) // преобразуем строку с датой из dto в LocalDate
                .build(); // создаем объект

        // берем список всех статей о пользователе и добавляем туда эту статью
        user.getArticles().add(article);
        // сохраняем статью в репозиторий статей
        articlesRepository.save(article);
        // возвращаем результат - преобразуем модель Article в ArticleDto, понятный клиенту
        return from(article);
    }
}

```

## Валидация

### javax.validation.constraints

* Это часть стандартной библиотеки валидации Java.

* `@NotNull`: Поле не должно быть null.
* `@NotBlank`: Строка не должна быть пустой или состоять только из пробелов.
* `@NotEmpty`: Коллекция или массив не должны быть пустыми.
* `@Min` : Значение поля должно быть больше или равно указанной минимальной границе.
* `@Max`: Значение поля должно быть меньше или равно указанной максимальной границе.
* `@Size` : Размер коллекции или строки должен находиться в определенных пределах (минимальный и максимальный размер).

### org.hibernate.validator.constraints

* Эта библиотека расширяет возможности `javax.validation.constraints` и добавляет некоторые дополнительные аннотации:

* `@Email` : Поле должно представлять собой корректный адрес электронной почты.
* `@Length` : Длина строки или массива должна быть в определенных пределах (минимальный и максимальный размер).
* `@Pattern`: Эта аннотация позволяет определить собственное регулярное выражение для проверки строки.

### Для того чтобы включить валидацию, нужно:

1. Подключить зависимость в pom.xml:

```xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

2. Повесить нужные аннотации на входящий dto:

```java
@Data
@Schema(description = "Данные для добавления пользователя")
public class NewUserDto {

    @Schema(description = "Email пользователя", example = "simple@mail.com")
    @Email
    @NotNull
    @NotBlank
    private String email;

    @Schema(description = "Пароль пользователя", example = "qwerty007")
    @NotBlank
    @Size(min = 7, max = 20)
    private String password;
}
```

3. В API-интерфейсе на входящий объект повесить аннотацию `@Valid`:

```java
UserDto addUser(@Parameter(required = true, description = "Пользователь") @RequestBody @Valid NewUserDto newUser);
```

### Если хотим выбросить свои ошибки?

1. А что происходит в "стандартном" варианте? - выбрасывается исключение - `MethodArgumentNotValidException`
2. Наша задача - научиться его перехватывать и возвращать свои данные вместо "стандартного ответа"
3. Создаем класс `ValidationExceptionHandler` с аннотацией `@ContrllerAdvice`
4. `@ControllerAdvice` позволяет `ValidationExceptionHandler` работать одновременно со всеми контроллерами и отслеживать их работу
5. Если в контроллере произойдет исключение (exception) - мы ее сможем перехватить
6. Это похоже на глобальный `try-catch` на все контроллеры
7. Вы можете столкнуться с ошибкой, что сервер не возвращает нормальный JSON, а отвечает 404
8. А проблема в том, что метод контроллера возвращает `UserDto`, а у нас возвращается `ValidationErrorsDto`
9. Проблема в несовпадении возвращаемого значения
10. Как починить? Нужно, чтобы и контроллер и перехватчик ошибки возвращали одно и то же - `ReponseEntity`
11. `ResponseEntity` - класс, который позволяет возвращать ответ любого типа для любого метода.

### Повторение валидации

* К нам от клиента приходит JSON-ка, например:

```json
{
  "email": "sidikov.marsel.com",
  "password": "                    "
}

```

* Мы хотим ее проверить (выполнить валидацию), для этого, в соответствующей DTO ставим нужные аннотации.
* Уже все работает хорошо, но мы хотим, чтобы клиент получал подробные сообщения об ошибках:

`400 Bad Request`

```json

{
  "errors": [
    {
      "field": "email",
      "message": "must be a well-formed email address",
      "rejectedValue": "sidikov.marsel.com"
    },
    {
      "field": "password",
      "message": "must not be blank",
      "rejectedValue": "                    "
    }
  ]
}
```

* Это подробное сообщение, которое содержит информацию обо всех ошибках
* Чтобы это сделать, мы создали класс `ValidationExceptionHandler`
* Его задача - перехватывать все ошибки валидации `MethodArgumentNotValidException` и переводить это все
* в адекватный JSON - `ValidationErrorsDto`
* Чтобы все работало ResponseEntity